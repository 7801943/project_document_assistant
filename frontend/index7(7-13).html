
<!DOCTYPE html>
<html lang="zh-CN" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的工作台</title>

    <script type="text/javascript" src="/static/base64.min.js" defer></script>
    <!-- Added from botui.html -->
    <script src="/static/marked.min.js"></script>
    <script src="/static/upload/upload_form.js" defer></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>

    <div class="app-wrapper">
        <header class="app-header">
            <div class="title-container"> <!-- Title and status in a container -->
                <div class="title">我的工作台</div>
                <span id="login-status-indicator"></span>
            </div>
            <div class="header-actions">
                <button id="upload-spec-button" class="auth-button login" style="background-color: #198754; margin-right: 10px;" title="上传本地规程目录">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cloud-arrow-up-fill" viewBox="0 0 16 16">
                        <path d="M8 2a5.53 5.53 0 0 0-3.594 1.342c-.766.66-1.321 1.52-1.464 2.383C1.266 6.095 0 7.555 0 9.318 0 11.366 1.708 13 3.781 13h8.906C14.502 13 16 11.57 16 9.773c0-1.636-1.242-2.969-2.834-3.194C12.923 3.999 10.69 2 8 2m2.354 5.146a.5.5 0 0 1-.708.708L8.5 6.707V10.5a.5.5 0 0 1-1 0V6.707L6.354 7.854a.5.5 0 1 1-.708-.708l2-2a.5.5 0 0 1 .708 0z"/>
                    </svg>
                    <span style="margin-left: 8px;">上传规程</span>
                </button>
                <button id="theme-toggle" class="theme-toggle-button" title="切换主题">
                    <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6M8 12a4 4 0 1 0 0-8 4 4 0 0 0 0 8M8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0m0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13m-4.646.354a.5.5 0 0 1-.708 0l-1.414-1.414a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708m9.193 0a.5.5 0 0 1 0-.708l1.414-1.414a.5.5 0 0 1 .708.707l-1.414 1.414a.5.5 0 0 1-.708 0m-9.193-9.193a.5.5 0 0 1-.708-.707l1.414-1.414a.5.5 0 1 1 .707.707L3.354 5.354a.5.5 0 0 1 0-.708M13.646 5.354a.5.5 0 0 1 0 .707L12.232 7.5a.5.5 0 0 1-.707-.707L13.646 5.354a.5.5 0 0 1 .708 0M1.5 8a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2A.5.5 0 0 1 1.5 8m13 0a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1h-2a.5.5 0 0 1-.5-.5"/></svg>
                    <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M6 .278a.77.77 0 0 1 .08.858 7.2 7.2 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277q.792-.001 1.533-.16a.79.79 0 0 1 .81.316.73.73 0 0 1-.031.893A8.35 8.35 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.75.75 0 0 1 6 .278"/></svg>
                </button>
                <a id="auth-button" href="/logout" class="auth-button logout"> <!-- Changed class and added id -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M10 12.5a.5.5 0 0 1-.5.5h-8a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5h8a.5.5 0 0 1 .5.5v2a.5.5 0 0 0 1 0v-2A1.5 1.5 0 0 0 9.5 2h-8A1.5 1.5 0 0 0 0 3.5v9A1.5 1.5 0 0 0 1.5 14h8a1.5 1.5 0 0 0 1.5-1.5v-2a.5.5 0 0 0-1 0z"/><path fill-rule="evenodd" d="M15.854 8.354a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708.708L14.293 7.5H5.5a.5.5 0 0 0 0 1h8.793l-2.147 2.146a.5.5 0 0 0 .708.708z"/></svg>
                    <span id="auth-button-text">登出</span> <!-- Added id -->
                </a>
            </div>
        </header>
        <main class="main-container">
            <div class="left-panel">
                <nav class="tab-navigation" id="tab-navigation-container">
                    <button id="workdir-tab-button" class="tab-button" title="查看工作目录">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-folder" viewBox="0 0 16 16">
                            <path d="M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31zM2.19 4a1 1 0 0 0-.996.816l.637 7a1 1 0 0 0 .995.816h10.348a1 1 0 0 0 .995-.816l.637-7A1 1 0 0 0 13.81 4H2.19zm4.69-1.707A1 1 0 0 0 6.172 2H2.5a1 1 0 0 0-1 .981l.006.139C1.72 3.72 1.94 4 2.19 4h11.62c.25-1 .47.28.72.28.006.139l.006.139a1 1 0 0 0-1-.981H9.828a1 1 0 0 0-.707-.293z"/>
                        </svg>
                        <span>工作目录</span>
                    </button>
                    <div id="tab-container"></div>
                </nav>
                <div class="content-viewer" id="content-viewer">
                    <div id="placeholder" class="placeholder" style="display: flex; width: 100%; height: 100%;"><span>请选择一个文件进行预览</span></div>
                    <div id="workdir-viewer" style="display: none;">
                        <h3 id="workdir-path">工作目录</h3>
                        <ul id="workdir-file-list" class="workdir-file-list">
                            <!-- 文件列表将动态填充于此 -->
                        </ul>
                    </div>
                </div>
            </div>
            <div class="right-panel">
                <!-- Content from botui.html's #chat-container, with its internal theme toggle button removed -->
                <div id="chat-container">
                    <div id="chat-header">
                        <span id="chat-title">聊天</span>
                        <button id="new-chat-button" title="开始一个新的对话">新对话</button>
                    </div>
                    <!-- botui.html's theme-toggle button was here, now removed -->
                    <div id="message-window"></div>
                    <form id="chat-form">
                        <textarea id="chat-input" placeholder="请输入消息 (Shift+Enter 换行)" rows="1"></textarea>
                        <button type="submit" title="发送" id="send-button">发送</button>
                        <button type="button" title="停止AI输出" id="stop-ai-button" style="margin-left: 5px; background-color: #ffc107; color: black;" disabled>停止</button>
                    </form>
                </div>
            </div>
        </main>
    </div>

    <!-- Upload Spec Modal Container -->
    <div id="upload-modal-container"></div>


<script>
    // --- Global State & DOM Refs from index4.html ---
    const appState = {
        openFiles: {},
        activeFile: null,
        sessionId: null,
        isLoggedIn: false, // 新增登录状态
        activeView: 'placeholder', // 新增：追踪当前视图 'placeholder', 'iframe', 'workdir'
    };
    // const chatbotIframe = document.getElementById('chatbot-iframe'); // Removed as iframe is replaced
    const tabContainer = document.getElementById('tab-container');
    const workdirTabButton = document.getElementById('workdir-tab-button');
    const placeholder = document.getElementById('placeholder');
    const contentViewer = document.getElementById('content-viewer'); // 新增：iframe 的容器
    const workdirViewer = document.getElementById('workdir-viewer');
    const loginStatusIndicator = document.getElementById('login-status-indicator');
    const authButton = document.getElementById('auth-button');
    const authButtonText = document.getElementById('auth-button-text');
    let chatSocket = null; // 新增聊天专用的 WebSocket

    // Login Modal DOM elements
    let loginModal, closeModalButton, modalLoginForm, modalUsernameInput, modalPasswordInput, modalRememberCheckbox, modalErrorBox;

    // Upload Modal DOM elements are now self-contained in upload_form.html
    // The trigger button is static
    const uploadSpecButton = document.getElementById('upload-spec-button');
    // The hide function needs to be global for the self-contained script to call it
    window.hideUploadModal = hideUploadModal;


    const MAX_WEBSOCKET_RETRIES = 5;
    const WEBSOCKET_RETRY_INTERVAL = 5000;

    let chatWebsocketRetryCount = 0; // 新增: 用于 chatSocket
    let chatWebsocketRetryTimer = null; // 新增: 用于 chatSocket

    // --- Theme Management from index4.html (controls everything) ---
    const themeToggle = document.getElementById('theme-toggle'); // This is index4.html's main theme toggle
    const getPreferredTheme = () => localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    const setTheme = (theme) => {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        // The chat component's theme should update automatically via CSS using html[data-theme='dark']
    };

    themeToggle.addEventListener('click', () => {
        const currentTheme = document.documentElement.getAttribute('data-theme');
        setTheme(currentTheme === 'dark' ? 'light' : 'dark');
    });

    // --- Viewer Logic from index4.html ---
    function showViewer(type, filename) {
        appState.activeView = type;

        // 隐藏所有主视图区域
        placeholder.style.display = 'none';
        workdirViewer.style.display = 'none';
        contentViewer.querySelectorAll('iframe').forEach(frame => frame.style.display = 'none');

        // 显示指定的视图
        if (type === 'placeholder') {
            placeholder.style.display = 'flex';
            placeholder.querySelector('span').textContent = filename; // filename is now the message
        } else if (type === 'workdir') {
            workdirViewer.style.display = 'block';
        } else if (type === 'iframe' && filename) { // Both markdown and others use iframe now
            const frame = contentViewer.querySelector(`iframe[data-filename="${filename}"]`);
            if (frame) {
                frame.style.display = 'block';
            } else {
                placeholder.style.display = 'flex';
                placeholder.querySelector('span').textContent = `正在加载 ${filename}...`;
            }
        }

        // 更新工作目录按钮的激活状态
        workdirTabButton.classList.toggle('active', type === 'workdir');

        // 如果不是查看文件，则清除文件标签的激活状态
        if (type !== 'iframe') {
            if (appState.activeFile) {
                appState.activeFile = null;
                renderTabs();
            }
        }
    }

    function viewFile(filename) {
        const file = appState.openFiles[filename];
        if (!file) {
            console.error(`Attempting to view a non-existent file: ${filename}`);
            showViewer('placeholder', `无法找到文件 ${filename} 的数据。`);
            return;
        }

        if (file.type === 'markdown') {
            viewMarkdownFile(filename);
        } else {
            viewIframeFile(filename);
        }
    }

    async function viewMarkdownFile(filename) {
        const file = appState.openFiles[filename];
        appState.activeFile = filename;
        renderTabs();

        showViewer('iframe', filename); // Markdown也使用iframe

        let frame = contentViewer.querySelector(`iframe[data-filename="${filename}"]`);
        if (!frame) {
            console.log(`Creating new iframe for Markdown: ${filename}`);
            try {
                const justTheFilename = filename.substring(filename.lastIndexOf('/') + 1);
                const fileDownloadUrl = `/download/${file.token}/${encodeURIComponent(justTheFilename)}`;

                // 将下载链接作为参数传递给 markdown.html
                const previewUrl = `/static/markdown.html?fileUrl=${encodeURIComponent(fileDownloadUrl)}`;

                const newFrame = document.createElement('iframe');
                newFrame.dataset.filename = filename;
                newFrame.style.cssText = 'width: 100%; height: 100%; border: none; display: none;';
                newFrame.src = previewUrl;
                contentViewer.appendChild(newFrame);

            } catch (error) {
                console.error(`Error preparing markdown preview for "${filename}":`, error);
                showViewer('placeholder', `准备Markdown预览 "${filename}" 出错: ${error.message}`);
                return;
            }
        }
        showViewer('iframe', filename);
        console.log(`Displaying iframe for markdown: ${filename}`);
    }

    function viewIframeFile(filename) {
        const file = appState.openFiles[filename];
        appState.activeFile = filename;
        renderTabs();

        showViewer('iframe', filename);

        let frame = contentViewer.querySelector(`iframe[data-filename="${filename}"]`);
        if (!frame) {
            console.log(`Creating new iframe for: ${filename}`);
            try {
                const fastapiBaseUrl = window.location.origin;
                //const justTheFilename = filename.substring(filename.lastIndexOf('/') + 1);
                // 注意：这里的下载URL是给kkfileview代理的，它需要一个完整的URL
                const justTheFilename = filename.substring(filename.lastIndexOf('/') + 1);
                const fileDownloadUrl = `http://host.docker.internal:8888/download/${file.token}/${encodeURIComponent(justTheFilename)}`;

                // 3. 构造指向后端 kkFileView 代理的 URL
                //    后端代理是 /api/v1/kkfileview/onlinePreview
                //    它期望一个 file_url 参数，其值是上面构造的 fileDownloadUrl
                //    根据您的反馈和 forward_test.html 的注释，fileDownloadUrl 在这里不应再次被 encodeURIComponent
                const previewProxyUrl = `${fastapiBaseUrl}/kkfileview/onlinePreview?file_url=${fileDownloadUrl}`;
                console.log(`[KKFileView] 请求预览代理 (iframe.src): ${previewProxyUrl} ,传递给代理的 file_url 参数值: ${fileDownloadUrl}`);

                const newFrame = document.createElement('iframe');
                newFrame.dataset.filename = filename;
                newFrame.style.cssText = 'width: 100%; height: 100%; border: none; display: none;';
                newFrame.src = previewProxyUrl;
                contentViewer.appendChild(newFrame);
            } catch (error) {
                console.error(`Error preparing file preview for "${filename}":`, error);
                showViewer('placeholder', `准备文件预览 "${filename}" 出错: ${error.message}`);
                return;
            }
        }
        showViewer('iframe', filename);
        console.log(`Displaying iframe for: ${filename}`);
    }

    // --- Tab Management Logic from index4.html ---
    function renderTabs() {
        tabContainer.innerHTML = '';
        const openFilenames = Object.keys(appState.openFiles);
        openFilenames.forEach(filename => {
            const file = appState.openFiles[filename];
            const button = document.createElement('button');
            button.className = 'tab-button';
            button.dataset.filename = filename;
            // 新增：将完整路径作为 tooltip
            button.title = filename;
            if (filename === appState.activeFile) button.classList.add('active');
            const icon = window.ICONS[file.format] || window.ICONS.default;
            // 新增：从完整路径中提取文件名
            const shortFilename = filename.substring(filename.lastIndexOf('/') + 1);
            button.innerHTML = `${icon}<span>${shortFilename}</span><span class="close-tab" title="关闭标签页">&times;</span>`;
            button.addEventListener('click', (e) => {
                if (e.target.classList.contains('close-tab')) return;
                viewFile(filename);
            });
            button.querySelector('.close-tab').addEventListener('click', (e) => {
                e.stopPropagation();
                closeTab(filename);
            });
            tabContainer.appendChild(button);
        });
        const activeTab = tabContainer.querySelector('.active');
        if (activeTab) {
            activeTab.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
        }
    }

    function closeTab(filename) {
        const file = appState.openFiles[filename];
        if (file) {
            // 所有文件类型都使用iframe
            const frame = contentViewer.querySelector(`iframe[data-filename="${filename}"]`);
            if (frame) {
                frame.remove();
                console.log(`Removed iframe for: ${filename}`);
            }

            delete appState.openFiles[filename];

            if (appState.activeFile === filename) {
                const remainingFiles = Object.keys(appState.openFiles);
                if (remainingFiles.length > 0) {
                    const newActiveFile = remainingFiles[remainingFiles.length - 1];
                    viewFile(newActiveFile);
                } else {
                    appState.activeFile = null;
                    showViewer('placeholder', '所有文件都已关闭。');
                }
            }
            renderTabs();
            updateWorkdirButtonStates();
        }
    }

    // --- WebSocket Logic for Chat ---
    function connectChatWebSocket() {
        if (!appState.sessionId) {
            console.error("无法连接聊天WebSocket：缺少session_id。");
            return;
        }
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        // 新的聊天WebSocket端点
        //
        const chatWsUrl = `${protocol}//${window.location.host}/ws/v2/chat?session_id=${appState.sessionId}`;
        //const chatWsUrl = `${protocol}//${window.location.host}/ws_chat_stream?session_id=${appState.sessionId}`;
        console.log(`正在连接到聊天 WebSocket: ${chatWsUrl}`);
        chatSocket = new WebSocket(chatWsUrl);

        chatSocket.onopen = () => {
            console.log("聊天WebSocket 连接已建立。");
            chatWebsocketRetryCount = 0;
            clearTimeout(chatWebsocketRetryTimer);
        };

        chatSocket.onmessage = (event) => {
            // console.debug("收到聊天WebSocket消息:", event.data);
            try {
                const message = JSON.parse(event.data);
                if (message.type === 'chat_event_batch' && message.payload && Array.isArray(message.payload)) {
                    if (!isStreaming) return; // 立即停止处理消息
                    message.payload.forEach(eventData => {
                        // console.debug("处理聊天事件:", eventData);
                        if (eventData.answer) {
                            botui_appendToCurrentBotMessage(eventData.answer);
                            if (current_task_id) {
                                botui_stopAIButton.disabled = false; // Enable button
                            }
                        } else if (eventData.event === 'agent_thought') {
                            if (eventData.task_id && !current_task_id) { // Capture task_id if not already set for this stream
                                current_task_id = eventData.task_id;
                                console.log("Captured task_id:", current_task_id);
                                botui_stopAIButton.disabled = false; // Enable button
                            }
                            const summaryParts = [];
                            let contentText = "";
                            if (eventData.thought) {
                                summaryParts.push('思考内容');
                                contentText += `思考内容: ${eventData.thought}\n`;
                            }
                            if (eventData.tool) {
                                summaryParts.push('调用工具');
                                contentText += `调用工具: ${eventData.tool}\n`;
                                if(eventData.tool_input) contentText += `工具输入: ${eventData.tool_input}\n`;
                            }
                            if (eventData.observation) {
                                if (!eventData.tool) summaryParts.push('工具结果');
                                contentText += `工具结果: ${eventData.observation}\n`;
                            }
                            if (summaryParts.length > 0 || contentText.trim()) {
                                const summaryText = summaryParts.length > 0 ? summaryParts.join('、') : 'Agent 思考步骤';
                                // 先结束当前的气泡
                                botui_finalizeCurrentBotMessage();
                                // 再添加工具信息
                                // 把工具调用，工具结果，全部放到一个折叠框里
                                if(eventData.observation){
                                botui_addCollapsibleMessage(`${summaryText} (点击展开)`, contentText.trim());
                                }
                            }
                        } else if (eventData.event === 'message_end') {
                            if (eventData.conversation_id) botui_conversation_id = eventData.conversation_id;
                            botui_finalizeCurrentBotMessage();
                            current_task_id = null; // Clear task_id as stream ended
                            botui_stopAIButton.disabled = true; // Disable button
                            botui_sendButton.disabled = false; // 重新启用发送按钮
                        } else if (eventData.conversation_id) {
                            botui_conversation_id = eventData.conversation_id;
                        }
                    });
                } else if (message.type === 'stop_request_processed') {
                    console.log("Stop request processed by server:", message);
                    botui_addMessage(`<i>已发送停止指令 (任务: ${message.task_id}, 状态: ${message.status})</i>`, 'bot');
                    if (message.status === 'success') {
                        // Stream should stop via Dify, message_end will handle UI cleanup
                        // botui_stopAIButton.style.display = 'none'; // Handled by message_end
                        // current_task_id = null; // Handled by message_end
                    }
                    botui_stopAIButton.disabled = true; // 停止按钮应被禁用，直到下一次流开始
                    botui_sendButton.disabled = false; // 重新启用发送按钮
                } else if (message.type === 'error') {
                    console.error("聊天WebSocket收到错误消息:", message.content, message.details || '');
                    botui_addMessage(`😥 **聊天服务器错误**: ${message.content}${message.details ? ` (${message.details})` : ''}`, 'bot');
                    botui_finalizeCurrentBotMessage();
                    current_task_id = null;
                    botui_stopAIButton.disabled = true; // Disable button
                    botui_sendButton.disabled = false; // 重新启用发送按钮
                } else if (message.type === 'file_open_request' && message.payload) { // 新增对 file_open_request 的处理
                    console.log("聊天WebSocket收到 file_open_request:", message.payload);
                    handleFileOpenRequest(message.payload); // 复用现有的处理函数
                } else if (message.type === 'directory_update' && message.payload) {
                    console.log("聊天WebSocket收到 directory_update:", message.payload);
                    handleDirectoryUpdate(message.payload);
                } else {
                    console.warn("收到未知的聊天WebSocket消息类型:", message);
                }
            } catch (e) {
                console.error("处理聊天WebSocket消息时出错:", e, "原始数据:", event.data);
            }
        };

        chatSocket.onclose = (event) => {
            console.warn(`聊天WebSocket 连接已关闭。代码: ${event.code}, 原因: '${event.reason}'`);
            clearTimeout(chatWebsocketRetryTimer);

            // Bug 3: 如果是服务器因为 session_id 无效而主动关闭，则不重连
            if (event.code === 1008 || event.code === 1011) {
                console.error(`服务器关闭连接 (代码: ${event.code})，原因: "${event.reason}"。停止重连。`);
                botui_addMessage(`与服务器的连接已断开: ${event.reason} 请尝试重新登录。`, 'bot');
                updateLoginStatusUI(false); // 更新UI到未登录状态，以提示用户重新登录
                return; // 明确阻止后续的重连逻辑
            }

            if (event.code === 1000 || event.code === 1001 || event.code === 1005) {
                console.log(`聊天WebSocket normally closed. Code: ${event.code}, Reason: '${event.reason}'`);
                if (appState.isLoggedIn) {
                    console.warn("聊天WebSocket closed normally but unexpectedly while logged in.");
                    handleChatWebSocketDisconnect(); // 调用新的处理函数
                }
                return;
            }
            console.warn(`聊天WebSocket abnormally closed. Code: ${event.code}, Reason: '${event.reason}'`);
            handleChatWebSocketDisconnect(); // 调用新的处理函数
        };

        chatSocket.onerror = (error) => {
            console.error("聊天WebSocket 发生错误:", error);
            if (chatSocket) chatSocket.close();
        };
    }


    function handleFileOpenRequest(fileInfo) {
        const { filename, download_token, format } = fileInfo;
        const isMarkdown = filename.toLowerCase().endsWith('.md') || filename.toLowerCase().endsWith('.markdown');

        // 检查文件是否已在打开的标签页中
        if (appState.openFiles[filename]) {
            console.log(`File ${filename} is already open. Switching to its tab.`);
            viewFile(filename); // 切换到已有的标签页
        } else {
            // 如果文件未打开，则添加到状态并查看
            console.log(`Opening new file: ${filename}`);
            appState.openFiles[filename] = {
                format: format,
                token: download_token,
                type: isMarkdown ? 'markdown' : 'iframe' // 增加类型区分
            };
            viewFile(filename);
        }
        // 无论文件是新打开还是已打开，都更新按钮状态
        updateWorkdirButtonStates();
    }

    function updateWorkdirButtonStates() {
        const openButtons = document.querySelectorAll('.workdir-action-btn.open-file-btn');
        openButtons.forEach(button => {
            const filePath = button.dataset.filepath;
            if (appState.openFiles[filePath]) {
                button.disabled = true;
            } else {
                button.disabled = false;
            }
        });
    }

    function handleDirectoryUpdate(payload) {
        const pathElement = document.getElementById('workdir-path');
        const listElement = document.getElementById('workdir-file-list');

        if (!pathElement || !listElement) {
            console.error('工作目录视图的必要元素未找到。');
            return;
        }

        // 更新目录路径并显示视图
        pathElement.textContent = '当前工作目录: ' + payload.directory;
        showViewer('workdir');

        // 清空旧的文件列表
        listElement.innerHTML = '';

        // 填充新的文件列表
        if (payload.files && payload.files.length > 0) {
            payload.files.forEach(file => {
                const listItem = document.createElement('li');

                const fileNameSpan = document.createElement('span');
                fileNameSpan.className = 'file-name';

                let displayPath = file.file_path;
                const parts = displayPath.split('/');

                // 检查路径是否至少有三个部分（例如 年份/项目名/文件名）
                // 如果是，则移除前两个部分
                if (parts.length > 2) {
                    displayPath = parts.slice(2).join('/');
                }

                fileNameSpan.textContent = displayPath;
                fileNameSpan.title = file.file_path; // 提示中仍显示完整路径

                const buttonGroup = document.createElement('div');
                buttonGroup.className = 'button-group';

                const openButton = document.createElement('button');
                openButton.textContent = '打开';
                openButton.className = 'workdir-action-btn open-file-btn';
                openButton.dataset.token = file.download_token;
                openButton.dataset.format = file.format;
                openButton.dataset.filepath = file.file_path;

                const llmReadButton = document.createElement('button');
                llmReadButton.textContent = 'LLM读取';
                llmReadButton.className = 'workdir-action-btn llm-read-btn';
                llmReadButton.dataset.filepath = file.file_path;

                buttonGroup.appendChild(openButton);
                buttonGroup.appendChild(llmReadButton);

                listItem.appendChild(fileNameSpan);
                listItem.appendChild(buttonGroup);
                listElement.appendChild(listItem);
            });
        } else {
            const emptyMessage = document.createElement('li');
            emptyMessage.textContent = '目录为空或不包含文件。';
            listElement.appendChild(emptyMessage);
        }
        // 渲染后，立即更新按钮状态
        updateWorkdirButtonStates();
    }


    // --- Login Modal Logic ---
    function initLoginModalDOM() {
        loginModal = document.getElementById('login-modal');
        closeModalButton = loginModal.querySelector('.close-modal-button');
        modalLoginForm = document.getElementById('modal-login-form');
        modalUsernameInput = document.getElementById('modal-username');
        modalPasswordInput = document.getElementById('modal-password');
        modalRememberCheckbox = document.getElementById('modal-remember');
        modalErrorBox = loginModal.querySelector('.error-message');

        closeModalButton.onclick = hideLoginModal;
        modalLoginForm.addEventListener('submit', handleModalLoginSubmit);
    }

    // --- Upload Modal Logic (Simplified for Self-Contained Component) ---
    async function showUploadModal() {
        if (!appState.isLoggedIn) {
            alert("请先登录再上传文件。");
            showLoginModal();
            return;
        }

        const modalContainer = document.getElementById('upload-modal-container');
        if (modalContainer.innerHTML.trim() !== '') {
            const modal = modalContainer.querySelector('.login-modal');
            if (modal) modal.style.display = 'flex';
            return;
        }

        try {
            // Step 1: Fetch categories data
            const infoResponse = await fetch('/api/upload-info');
            if (!infoResponse.ok) {
                const errorData = await infoResponse.json();
                throw new Error(errorData.detail || `无法加载上传信息: ${infoResponse.statusText}`);
            }
            const infoData = await infoResponse.json();

            // Step 2: Fetch the HTML template
            const templateResponse = await fetch('/static/upload/upload_form.html');
            if (!templateResponse.ok) {
                throw new Error(`无法加载上传表单模板: ${templateResponse.statusText}`);
            }
            const formHtml = await templateResponse.text();

            // Step 3: Inject the HTML
            modalContainer.innerHTML = formHtml;

            // Step 4: Initialize the form with the fetched data
            // This function is now available from the globally loaded upload_form.js
            initializeUploadForm(infoData.categories);

            // Step 5: Show the modal and attach closing event listener
            const modal = document.getElementById('upload-spec-modal');
            if (modal) {
                modal.style.display = 'flex';
                modal.addEventListener('click', (event) => {
                    if (event.target === modal || event.target.id === 'close-upload-modal-button') {
                        hideUploadModal();
                    }
                });
            }

        } catch (error) {
            console.error('显示上传模块失败:', error);
            alert(`错误: ${error.message}`);
        }
    }

    function hideUploadModal() {
        const modalContainer = document.getElementById('upload-modal-container');
        modalContainer.innerHTML = ''; // Remove the modal from the DOM
    }

    function showLoginModal() {
        if (!loginModal) initLoginModalDOM(); // Initialize DOM elements if not already done
        modalErrorBox.textContent = ''; // Clear previous errors
        loginModal.style.display = 'flex'; // Use flex for centering
        modalUsernameInput.focus();
    }

    function hideLoginModal() {
        if (loginModal) loginModal.style.display = 'none';
    }

    async function handleModalLoginSubmit(event) {
        event.preventDefault();
        modalErrorBox.textContent = '';
        const formData = new FormData(modalLoginForm);

        try {
            const response = await fetch('/login', { method: 'POST', body: formData });
            const result = await response.json();

            if (response.ok) {
                hideLoginModal();
                // Login successful, re-check status and initialize app parts
                await checkLoginStatusAndInitialize(true); // Pass true to indicate this is after a login attempt
            } else {
                modalErrorBox.textContent = result.message || '登录失败，请重试。';
            }
        } catch (error) {
            console.error('登录请求失败:', error);
            modalErrorBox.textContent = '发生网络错误，请检查您的连接。';
        }
    }

    // --- UI Update for Login Status ---
    function updateLoginStatusUI(isLoggedIn) {
        appState.isLoggedIn = isLoggedIn;
        if (isLoggedIn) {
            loginStatusIndicator.textContent = '（已登录）';
            authButtonText.textContent = '登出';
            authButton.href = '/logout'; // Standard logout link
            authButton.classList.remove('login');
            authButton.classList.add('logout');
            authButton.onclick = async (e) => { // Handle logout click
                e.preventDefault();
                    const currentSessionId = appState.sessionId; // Store before clearing
                    try {
                        // 后端 /logout 是 GET 请求
                        await fetch('/logout', { method: 'GET' });
                    } catch (error) {
                        console.error("Logout request failed:", error);
                    } finally {
                        appState.sessionId = null; // Clear session ID
                        sessionStorage.removeItem('session_id');
                        if (chatSocket && chatSocket.readyState === WebSocket.OPEN) {
                            chatSocket.close(1000, "User logged out");
                        }
                        chatSocket = null;
                        updateLoginStatusUI(false); // Update UI to logged out state
                        // showViewer('placeholder', '您已登出。请重新登录以继续。');
                    // botui_messageWindow.innerHTML = ''; // Do not clear chat messages
                    // botui_conversation_id = null; // Do not reset conversation
                }
            };
        } else {
            loginStatusIndicator.textContent = '（未登录）';
            authButtonText.textContent = '登录';
            authButton.href = 'javascript:void(0);'; // Prevent navigation
            authButton.classList.remove('logout');
            authButton.classList.add('login');
            authButton.onclick = (e) => { // Show login modal on click
                e.preventDefault();
                showLoginModal();
            };
            // Content (tabs, iframe, chat) is NOT cleared immediately on logout or disconnect.
            // It will be handled/cleared upon a new successful login or if explicitly cleared by other actions.
            // appState.openFiles = {}; // Do not clear
            // appState.activeFile = null; // Do not clear
            // renderTabs(); // Do not clear tabs
            // if (!fileViewerIframe.src.includes('about:blank')) fileViewerIframe.src = 'about:blank'; // Do not clear iframe
            showViewer('placeholder', '请登录以使用我的工作台。'); // Placeholder can still update
        }
    }

    // --- WebSocket Disconnect Handling for Chat Socket ---
    function handleChatWebSocketDisconnect() {
        console.warn("聊天WebSocket disconnected or failed to connect.");
        if (chatSocket && (chatSocket.readyState === WebSocket.OPEN || chatSocket.readyState === WebSocket.CONNECTING)) {
            try { chatSocket.close(); } catch(e) { console.warn("Error closing chatSocket:", e); }
        }
        chatSocket = null;

        if (appState.isLoggedIn) {
            if (chatWebsocketRetryCount < MAX_WEBSOCKET_RETRIES) {
                chatWebsocketRetryCount++;
                console.log(`Attempting to reconnect 聊天WebSocket (attempt ${chatWebsocketRetryCount}/${MAX_WEBSOCKET_RETRIES}) in ${WEBSOCKET_RETRY_INTERVAL / 1000} seconds...`);
                clearTimeout(chatWebsocketRetryTimer);
                chatWebsocketRetryTimer = setTimeout(connectChatWebSocket, WEBSOCKET_RETRY_INTERVAL);
            } else {
                console.error(`聊天WebSocket reconnection failed after ${MAX_WEBSOCKET_RETRIES} attempts.`);
                botui_addMessage("与聊天服务器的连接已断开，聊天功能可能无法使用。您可以尝试刷新页面或稍后重试。", "bot");
            }
        } else {
            console.log("聊天WebSocket not attempting reconnection as user is not logged in.");
        }
    }

    // --- App Initialization (Revised) ---
    async function checkLoginStatusAndInitialize(isAfterLoginAttempt = false) {
        try {
            const response = await fetch('/api/user/status');
            if (response.ok) {
                const userData = await response.json();
                const previousSessionId = appState.sessionId;
                sessionStorage.setItem('session_id', userData.session_id);
                appState.sessionId = userData.session_id;
                updateLoginStatusUI(true); // Set to logged-in state
                hideLoginModal(); // 确保登录成功后模态框是隐藏的

                if (isAfterLoginAttempt && previousSessionId && previousSessionId !== appState.sessionId) {
                    // If logged in as a new/different user, clear old state
                    console.log("New user session detected after login. Clearing previous state.");
                    appState.openFiles = {};
                    appState.activeFile = null;
                    renderTabs();
                    if (!fileViewerIframe.src.includes('about:blank')) fileViewerIframe.src = 'about:blank';
                    botui_messageWindow.innerHTML = '';
                    botui_conversation_id = null;
                }

                connectChatWebSocket();    // 连接聊天专用 WebSocket

                if (isAfterLoginAttempt) { // If this was after a successful login
                     showViewer('placeholder', '登录成功！我的工作台已就绪。');
                }
            } else if (response.status === 401) {
                // 用户未登录或会话无效，恢复为UI更新和模态框逻辑
                updateLoginStatusUI(false);
                // 不再重定向，而是依赖UI提示用户登录
            } else {
                throw new Error(`获取用户状态失败: ${response.status}`);
            }
        } catch (error) {
            console.error('检查登录状态或初始化应用时出错:', error);
            // 发生错误时，同样更新UI，而不是重定向
            updateLoginStatusUI(false);
            botui_addMessage(`无法连接到服务器进行状态检查: ${error.message}`, 'bot');
        }

        // Common initialization steps regardless of login status (e.g., loading non-user-specific resources)
        // Get chatbot API config (moved here to run even if not initially logged in, though chat might be disabled)
        try {
            const agentApiResponse = await fetch('/api/dify-agent-api');
            if (!agentApiResponse.ok) {
                throw new Error(`获取聊天机器人配置失败: ${agentApiResponse.status} ${agentApiResponse.statusText}`);
            }
            const agentApiData = await agentApiResponse.json();
            if (agentApiData.url && agentApiData.apikey) {
                dynamic_bot_api_url = agentApiData.url;
                dynamic_bot_api_key = agentApiData.apikey;
                console.log("聊天机器人配置已加载:", dynamic_bot_api_url);
            } else {
                console.error('未能从API获取有效的聊天机器人URL或API Key。');
                // Don't show placeholder error here if not logged in, as chat is likely disabled anyway
            }
        } catch (error) {
            console.error('获取聊天机器人配置时出错:', error);
        }

        if (!isAfterLoginAttempt && !appState.isLoggedIn) {
             showViewer('placeholder', '请登录以使用我的工作台。');
        } else if (!isAfterLoginAttempt && appState.isLoggedIn) {
             showViewer('placeholder', '我的工作台已就绪。');
        }
        // renderTabs(); // Already called in init
    }

    async function init() {
        setTheme(getPreferredTheme());

        // 为工作目录标签页按钮添加事件监听器
        workdirTabButton.addEventListener('click', () => {
            if (appState.activeView !== 'workdir') {
                showViewer('workdir');
            } else {
                // 如果当前已是工作目录视图，则切换回默认占位符
                showViewer('placeholder', '我的工作台已就绪。');
            }
        });

        // 使用事件委托处理文件打开和LLM读取按钮的点击
        document.addEventListener('click', function(event) {
            const button = event.target;
            if (button && button.classList.contains('open-file-btn')) {
                const fileInfo = {
                    filename: button.dataset.filepath, // 使用完整路径作为唯一标识
                    download_token: button.dataset.token,
                    format: button.dataset.format
                };
                handleFileOpenRequest(fileInfo);
            } else if (button && button.classList.contains('llm-read-btn')) {
                const filePath = button.dataset.filepath;
                if (filePath) {
                    const query = `请读取文件，路径是 ${filePath}`;
                    // 直接调用聊天函数
                    botui_addMessage(query, 'user');
                    botui_streamMessageViaWebSocket(query);
                }
            }
        });

        // Create and append login modal to body before initializing DOM refs for it
        const loginModalHTML = `
        <div id="login-modal" class="login-modal">
            <div class="login-modal-content">
                <span class="close-modal-button">&times;</span>
                <h1>工作台登录</h1>
                <form id="modal-login-form">
                    <div class="form-group">
                        <label for="modal-username">用户名:</label>
                        <input type="text" id="modal-username" name="username" required>
                    </div>
                    <div class="form-group">
                        <label for="modal-password">密码:</label>
                        <input type="password" id="modal-password" name="password" required>
                    </div>
                    <div class="remember-group">
                        <input type="checkbox" id="modal-remember" name="remember" value="true">
                        <label for="modal-remember" style="margin-left: 8px; margin-bottom: 0;">记住我</label>
                    </div>
                    <button type="submit">登 录</button>
                    <div class="error-message" id="modal-error-box"></div>
                </form>
            </div>
        </div>`;
        document.body.insertAdjacentHTML('beforeend', loginModalHTML);

        initLoginModalDOM(); // Initialize static login modal DOM elements
        uploadSpecButton.onclick = showUploadModal; // Attach listener to the static upload button
        await checkLoginStatusAndInitialize();
        renderTabs(); // Initial tab render
    }

    // --- ICONS from index4.html ---
    window.ICONS = {
        pdf: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 14V4.5L9.5 0H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2M9.5 3A1.5 1.5 0 0 0 11 4.5h2V14a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h5.5z"/><path d="M4.603 14.087a.8.8 0 0 1-1.214-.886l.66-1.98a.52.52 0 0 1 .184-.282l.062-.052.062-.052a.5.5 0 0 1 .736.646l-.119.119a.11.11 0 0 0-.03.076l-.23.69zM5.53 12.042a.51.51 0 0 1 .707.707l-1.464 1.464a.51.51 0 0 1-.707-.707z"/></svg>`,
        docx: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8.88 15.84c-.45.08-.91.16-1.38.16H2.5A1.5 1.5 0 0 1 1 14.5V3.5A1.5 1.5 0 0 1 2.5 2H10v2h2v1.5a.5.5 0 0 0 1 0V4h.5a.5.5 0 0 0 .29-.91L11.15.29a.5.5 0 0 0-.85.35V2.5A1.5 1.5 0 0 1 9 1H2.5A2.5 2.5 0 0 0 0 3.5v11A2.5 2.5 0 0 0 2.5 17h6.08c.55 0 1.07-.1 1.55-.27l.5-.27c.45-.25.85-.58 1.17-1a.5.5 0 0 0-.85-.52c-.25.3-.57.54-.9.74l-.5.27Z"/><path d="M16 12h-3a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1h3a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1m-3-2h3v1h-3z"/></svg>`,
        xlsx: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M5.18 4.603L1.18 8.603h2.825L8 4.306zm3.593 0L5.18 10.297h2.825L12 5.006zM13.18 4.603L9.18 8.603h2.825L16 4.306zM13.18 10.297L9.18 14.297h2.825L16 9.006z"/><path d="M1.18 8.603a.5.5 0 0 0 .306.491l6.98 3.293a.5.5 0 0 0 .468 0l6.98-3.293a.5.5 0 0 0 .306-.491L9.18 1.497a.5.5 0 0 0-.468 0zM8.944 1.151l6.98 3.293L8.944 7.739 1.964 4.444zM1.964 9.098l6.98 3.293 6.98-3.293-6.98-3.294z"/></svg>`,
        default: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5zM4 1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2A1.5 1.5 0 0 1 9.5 3V1z"/></svg>`
    };

    // --- JavaScript from botui.html (integrated and prefixed) ---
    let dynamic_bot_api_url = null; // 将通过API获取
    let dynamic_bot_api_key = null; // 将通过API获取

    const botui_messageWindow = document.getElementById('message-window');
    const botui_chatForm = document.getElementById('chat-form');
    const botui_chatInput = document.getElementById('chat-input');
    const botui_sendButton = document.getElementById('send-button'); // send-button ID was added in HTML
    const botui_stopAIButton = document.getElementById('stop-ai-button'); // stop-ai-button ID was added in HTML
    const botui_newChatButton = document.getElementById('new-chat-button');

    let botui_conversation_id = null;
    let current_task_id = null; // To store the current Dify task_id
    let isStreaming = false; // 新增流式传输状态
    let currentBotMessageElement = null; // Make this global for stop button logic and message appending

    // botui.html's theme toggle JS logic is removed. index4.html's setTheme handles global theme.

    function startNewConversation() {
        botui_conversation_id = null;
        botui_messageWindow.innerHTML = '';
        botui_addMessage("新对话已开始。请输入您的问题。", "bot");
        console.log("New conversation started. Conversation ID reset.");
        botui_chatInput.focus();
    }

    botui_newChatButton.addEventListener('click', startNewConversation);

    function botui_handleFormSubmission() {
        const query = botui_chatInput.value.trim();
        if (query) {
            botui_addMessage(query, 'user');
            current_task_id = null; // Reset task_id for new query
            botui_stopAIButton.disabled = true; // Disable button
            botui_sendButton.disabled = true; // 禁用发送按钮
            botui_streamMessageViaWebSocket(query);
            botui_chatInput.value = '';
            botui_chatInput.style.height = 'auto';
        }
    }

    botui_chatForm.addEventListener('submit', (event) => {
        event.preventDefault();
        botui_handleFormSubmission();
    });

    botui_stopAIButton.addEventListener('click', () => {
        if (current_task_id && chatSocket && chatSocket.readyState === WebSocket.OPEN) {
            console.log(`Requesting to stop AI task: ${current_task_id}`);
            console.log(`WebSocket state: ${chatSocket.readyState}`);
            console.log(`WebSocket bufferedAmount: ${chatSocket.bufferedAmount}`);
            isStreaming = false; // 立即停止前端渲染
            chatSocket.send(JSON.stringify({
                type: "stop_chat_stream",
                task_id: current_task_id,
                user: "user_001" // This should match the user ID sent in chat requests
            }));
            botui_stopAIButton.disabled = true; // Disable button after sending stop request
            setTimeout(() => {
                botui_addMessage('<i>正在尝试停止AI输出...</i>', 'bot');
            }, 0);
        } else {
            console.warn("Cannot stop AI: No active task_id or WebSocket not open.");
            // Button is already visible, ensure it's disabled if no task_id
            if (!current_task_id) {
                botui_stopAIButton.disabled = true;
            }
        }
    });

    botui_chatInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            botui_handleFormSubmission();
        }
    });

    botui_chatInput.addEventListener('input', () => {
        botui_chatInput.style.height = 'auto';
        // Ensure scrollHeight is calculated correctly after content change
        requestAnimationFrame(() => {
             botui_chatInput.style.height = (botui_chatInput.scrollHeight) + 'px';
        });
    });

    function botui_addMessage(content, type, referenceNode = null) {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${type}-message`;
        if (type === 'user') {
            messageElement.textContent = content; // Use textContent for user messages to prevent XSS
        } else {
            messageElement.innerHTML = content;
        }
        if (referenceNode) {
            botui_messageWindow.insertBefore(messageElement, referenceNode);
        } else {
            botui_messageWindow.appendChild(messageElement);
        }
        botui_scrollToBottom();
        return messageElement;
    }

    function botui_addCollapsibleMessage(summaryText, contentText, referenceNode = null) {
        if (!contentText) return;
        const detailsElement = document.createElement('details');
        detailsElement.className = 'message agent-thought';
        const summaryElement = document.createElement('summary');
        summaryElement.textContent = summaryText;
        const contentDiv = document.createElement('div');
        contentDiv.className = 'collapsible-content';
        contentDiv.innerHTML = marked.parse(contentText);
        detailsElement.appendChild(summaryElement);
        detailsElement.appendChild(contentDiv);

        // 确保在 finalize 之后，新的 collapsible message 被正确添加
        // 如果 referenceNode 存在且仍在 DOM 中，则在其前插入
        if (referenceNode && referenceNode.parentNode === botui_messageWindow) {
            botui_messageWindow.insertBefore(detailsElement, referenceNode);
        } else {
            // 否则，直接追加到末尾
            botui_messageWindow.appendChild(detailsElement);
        }
        setTimeout(botui_scrollToBottom, 0);
    }

    function botui_scrollToBottom() {
        botui_messageWindow.scrollTop = botui_messageWindow.scrollHeight;
    }

    function botui_appendToCurrentBotMessage(textChunk) {
        if (!isStreaming) return; // 如果已停止，则不处理
        if (!currentBotMessageElement) {
            const thinkingHTML = `<div class="thinking"><span></span><span></span><span></span></div>`;
            currentBotMessageElement = botui_addMessage(thinkingHTML, 'bot');
            currentBotMessageElement.dataset.fullText = ""; // 初始化完整文本
        }

        const thinkingIndicator = currentBotMessageElement.querySelector('.thinking');
        if (thinkingIndicator) { // 首次接收到文本块时，移除loading动画
            currentBotMessageElement.innerHTML = ''; // 清空loading
        }

        currentBotMessageElement.dataset.fullText += textChunk;
        currentBotMessageElement.innerHTML = marked.parse(currentBotMessageElement.dataset.fullText);
        botui_scrollToBottom();
    }

    function botui_getCurrentBotMessageElement() {
        return currentBotMessageElement;
    }

    function botui_finalizeCurrentBotMessage() {
        if (currentBotMessageElement && currentBotMessageElement.classList.contains('bot-message')) {
            const thinkingIndicator = currentBotMessageElement.querySelector('.thinking');
            // 如果消息元素仍然只包含 thinking 动画（即没有收到任何文本），
            // 可以选择移除它或替换为一个“无回复”的提示。
            if (thinkingIndicator && (!currentBotMessageElement.dataset.fullText || currentBotMessageElement.dataset.fullText.trim() === '')) {
                 currentBotMessageElement.innerHTML = marked.parse("..."); // 或其他占位符，或移除
            }
        }
        currentBotMessageElement = null; // 重置，以便下次创建新消息
        botui_scrollToBottom();
    }

    async function botui_streamMessageViaWebSocket(query) {
        if (!chatSocket || chatSocket.readyState !== WebSocket.OPEN) {
            console.warn("聊天WebSocket未连接或未打开。尝试重新连接...");
            botui_addMessage("与聊天服务器的连接已断开，正在尝试重新连接...", "bot");
            // connectChatWebSocket(); // Let the existing onclose handler manage reconnections
            // Instead of direct reconnect, inform user and rely on onclose handler
            if (!chatWebsocketRetryTimer) { // Avoid queuing multiple reconnects if already trying
                 handleChatWebSocketDisconnect(); // Trigger the standard reconnect procedure
            }
            // Provide feedback that message might not be sent immediately
            botui_addMessage("连接问题，请稍后或消息发送成功后重试。", "bot");
            botui_sendButton.disabled = false; // 如果websocket未连接，重新启用发送按钮
            return;
        }

        isStreaming = true; // 开始流式传输
        current_task_id = null; // Reset task_id for the new stream
        botui_stopAIButton.disabled = true; // Ensure stop button is disabled at the start of a new stream


        // Initialize a new bot message element for thinking animation and subsequent stream
        const thinkingHTML = `<div class="thinking"><span></span><span></span><span></span></div>`;
        currentBotMessageElement = botui_addMessage(thinkingHTML, 'bot'); // This is now a global var
        currentBotMessageElement.dataset.fullText = ""; // Initialize

        const payload = {
            query: query,
            user: "user_001", // 可以根据实际用户身份调整
            conversation_id: botui_conversation_id || null,
            inputs: {} // 其他可能的输入参数
        };

        try {
            console.log("通过WebSocket发送聊天请求:", payload);
            chatSocket.send(JSON.stringify(payload));
        } catch (error) {
            console.error("通过WebSocket发送消息失败:", error);
            if (currentBotMessageElement) {
                 currentBotMessageElement.innerHTML = marked.parse(`😥 **抱歉，发送消息时出错了**: \n\n\`\`\`\n${error.message}\n\`\`\``);
            } else {
                botui_addMessage(`😥 **抱歉，发送消息时出错了**: \n\n\`\`\`\n${error.message}\n\`\`\``, 'bot');
            }
            botui_finalizeCurrentBotMessage(); // 确保重置
            botui_sendButton.disabled = false; // 发送失败时重新启用发送按钮
        }
        // 注意：WebSocket是异步的，消息的接收和处理在 chatSocket.onmessage 中进行
    }
    // --- End of JavaScript from botui.html ---

    window.addEventListener('load', init);
</script>
</body>
</html>
